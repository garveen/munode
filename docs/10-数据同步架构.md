# ShitSpeak Node.js 重写项目 - 数据同步架构

## 架构原则

### 数据所有权划分

1. **Hub Server (中心服务器)** - 唯一的数据源
   - 持久化存储：SQLite 数据库
   - 数据包括：
     - 频道结构 (channels, channel_links)
     - ACL 权限 (acls)
     - 封禁列表 (bans)
     - 用户最后频道 (user_last_channels)
     - 全局配置 (configs)
     - 审计日志 (audit_logs)

2. **Edge Server (边缘服务器)** - 无状态/内存缓存
   - 仅使用内存存储
   - 数据包括：
     - 频道树缓存（从 Hub 同步）
     - ACL 缓存（从 Hub 同步）
     - 封禁列表缓存（从 Hub 同步）
     - 本地会话状态
     - 临时封禁（短期 IP 限流）
   - 可选：GeoIP 数据库（只读，不涉及业务数据）

## 数据同步机制

### 初始化同步 (Full Sync)

Edge Server 启动或重连时执行完整同步：

```typescript
// Edge Server 启动流程
async function initializeEdgeServer() {
  // 1. 连接到 Hub Server
  await connectToHub();
  
  // 2. 请求完整数据快照
  const snapshot = await hubClient.requestFullSnapshot({
    edgeServerId: config.serverId,
  });
  
  // 3. 加载到内存
  await loadSnapshot(snapshot);
  
  // 4. 订阅增量更新
  await subscribeToUpdates();
  
  logger.info('Edge server initialized and synced');
}

interface FullSnapshot {
  channels: ChannelData[];
  channelLinks: ChannelLinkData[];
  acls: ACLData[];
  bans: BanData[];
  configs: Record<string, any>;
  timestamp: number;
}
```

### 增量同步 (Incremental Sync)

Hub Server 广播数据变更给所有 Edge：

```typescript
// Hub Server 广播变更
class HubBroadcaster {
  // 频道变更
  async broadcastChannelUpdate(update: ChannelUpdate) {
    const message = {
      type: 'channel.update',
      data: update,
      timestamp: Date.now(),
    };
    
    // 广播给所有 Edge
    for (const edge of this.activeEdges) {
      await edge.send(message);
    }
  }
  
  // ACL 变更
  async broadcastACLUpdate(channelId: number, acls: ACL[]) {
    const message = {
      type: 'acl.update',
      data: { channelId, acls },
      timestamp: Date.now(),
    };
    
    for (const edge of this.activeEdges) {
      await edge.send(message);
    }
  }
  
  // 封禁变更
  async broadcastBanUpdate(action: 'add' | 'remove', ban: BanData) {
    const message = {
      type: 'ban.update',
      data: { action, ban },
      timestamp: Date.now(),
    };
    
    for (const edge of this.activeEdges) {
      await edge.send(message);
    }
  }
}
```

### Edge Server 内存存储

```typescript
// Edge Server 内存状态管理
class EdgeStateManager {
  private channels: Map<number, ChannelData> = new Map();
  private channelTree: ChannelNode | null = null;
  private acls: Map<number, ACL[]> = new Map(); // channelId -> ACLs
  private bans: BanCache;
  private configs: Map<string, any> = new Map();
  private lastSyncTimestamp: number = 0;
  
  /**
   * 加载完整快照
   */
  async loadSnapshot(snapshot: FullSnapshot): Promise<void> {
    // 清空现有数据
    this.channels.clear();
    this.acls.clear();
    
    // 加载频道
    for (const channel of snapshot.channels) {
      this.channels.set(channel.id, channel);
    }
    
    // 构建频道树
    this.channelTree = this.buildChannelTree(snapshot.channels, snapshot.channelLinks);
    
    // 加载 ACL
    for (const acl of snapshot.acls) {
      if (!this.acls.has(acl.channel_id)) {
        this.acls.set(acl.channel_id, []);
      }
      this.acls.get(acl.channel_id)!.push(acl);
    }
    
    // 加载封禁
    this.bans = new BanCache(snapshot.bans);
    
    // 加载配置
    for (const [key, value] of Object.entries(snapshot.configs)) {
      this.configs.set(key, value);
    }
    
    this.lastSyncTimestamp = snapshot.timestamp;
    logger.info('Snapshot loaded', { 
      channels: this.channels.size,
      bans: snapshot.bans.length,
    });
  }
  
  /**
   * 处理增量更新
   */
  async handleUpdate(update: SyncUpdate): Promise<void> {
    switch (update.type) {
      case 'channel.create':
        this.channels.set(update.data.id, update.data);
        this.rebuildChannelTree();
        break;
        
      case 'channel.update':
        if (this.channels.has(update.data.id)) {
          this.channels.set(update.data.id, {
            ...this.channels.get(update.data.id)!,
            ...update.data,
          });
          this.rebuildChannelTree();
        }
        break;
        
      case 'channel.delete':
        this.channels.delete(update.data.id);
        this.acls.delete(update.data.id);
        this.rebuildChannelTree();
        break;
        
      case 'acl.update':
        this.acls.set(update.data.channelId, update.data.acls);
        break;
        
      case 'ban.add':
        this.bans.add(update.data);
        break;
        
      case 'ban.remove':
        this.bans.remove(update.data.id);
        break;
        
      case 'config.update':
        this.configs.set(update.data.key, update.data.value);
        break;
    }
    
    this.lastSyncTimestamp = update.timestamp;
  }
  
  /**
   * 构建频道树
   */
  private buildChannelTree(
    channels: ChannelData[], 
    links: ChannelLinkData[]
  ): ChannelNode {
    // 找到根频道 (id=0, parent_id=-1)
    const root = channels.find(ch => ch.id === 0);
    if (!root) {
      throw new Error('Root channel not found');
    }
    
    // 递归构建树
    const buildNode = (channel: ChannelData): ChannelNode => {
      const children = channels
        .filter(ch => ch.parent_id === channel.id)
        .sort((a, b) => a.position - b.position)
        .map(buildNode);
      
      const linkedChannels = links
        .filter(link => link.channel_id === channel.id)
        .map(link => link.target_id);
      
      return {
        ...channel,
        children,
        links: linkedChannels,
      };
    };
    
    return buildNode(root);
  }
  
  /**
   * 检查权限 (从内存读取)
   */
  hasPermission(
    userId: number, 
    channelId: number, 
    permission: Permission
  ): boolean {
    const acls = this.acls.get(channelId) || [];
    // 实现权限计算逻辑
    return calculatePermission(userId, channelId, permission, acls, this.channelTree);
  }
  
  /**
   * 检查是否被封禁 (从内存读取)
   */
  isBanned(ip: string, certHash?: string): BanCheckResult {
    return this.bans.check(ip, certHash);
  }
}
```

## 同步协议设计

### gRPC 服务定义

```protobuf
// sync.proto
syntax = "proto3";

package shitspeak.sync;

// 同步服务
service SyncService {
  // 请求完整快照
  rpc RequestFullSnapshot(SnapshotRequest) returns (FullSnapshot);
  
  // 订阅增量更新 (Server Streaming)
  rpc SubscribeUpdates(SubscribeRequest) returns (stream SyncUpdate);
  
  // 心跳保持连接
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
}

message SnapshotRequest {
  int32 edge_server_id = 1;
  int64 last_sync_timestamp = 2; // 用于断线重连
}

message FullSnapshot {
  repeated Channel channels = 1;
  repeated ChannelLink channel_links = 2;
  repeated ACL acls = 3;
  repeated Ban bans = 4;
  map<string, string> configs = 5;
  int64 timestamp = 6;
}

message SyncUpdate {
  string type = 1; // channel.create, channel.update, etc.
  bytes data = 2;  // JSON encoded data
  int64 timestamp = 3;
  int64 sequence = 4; // 顺序号，用于检测丢失
}

message Channel {
  int32 id = 1;
  string name = 2;
  int32 position = 3;
  int32 max_users = 4;
  int32 parent_id = 5;
  bool inherit_acl = 6;
  string description_blob = 7;
  bool managed = 8;
}

message ChannelLink {
  int32 channel_id = 1;
  int32 target_id = 2;
}

message ACL {
  int32 id = 1;
  int32 channel_id = 2;
  int32 user_id = 3;
  string group = 4;
  bool apply_here = 5;
  bool apply_subs = 6;
  uint32 allow = 7;
  uint32 deny = 8;
}

message Ban {
  int32 id = 1;
  bytes address = 2;
  int32 mask = 3;
  string name = 4;
  string hash = 5;
  string reason = 6;
  int64 start = 7;
  int32 duration = 8;
}

message SubscribeRequest {
  int32 edge_server_id = 1;
  int64 from_sequence = 2; // 从哪个序列号开始
}

message HeartbeatRequest {
  int32 edge_server_id = 1;
  int64 last_received_sequence = 2;
}

message HeartbeatResponse {
  bool ok = 1;
  int64 current_sequence = 2;
  int64 missing_updates = 3; // 如果有丢失的更新
}
```

## 容错机制

### 1. 断线重连

```typescript
class SyncClient {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  private reconnectDelay = 1000; // 1秒，指数退避
  
  async connect(): Promise<void> {
    try {
      await this.establishConnection();
      this.reconnectAttempts = 0;
      
      // 检查是否需要重新同步
      const needsFullSync = await this.checkSyncStatus();
      if (needsFullSync) {
        await this.performFullSync();
      }
      
      // 订阅增量更新
      await this.subscribeToUpdates();
      
    } catch (error) {
      logger.error('Connection failed', error);
      await this.handleReconnect();
    }
  }
  
  private async handleReconnect(): Promise<void> {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      logger.fatal('Max reconnect attempts reached, shutting down');
      process.exit(1);
    }
    
    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
    
    logger.info(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
    await new Promise(resolve => setTimeout(resolve, delay));
    
    await this.connect();
  }
}
```

### 2. 更新丢失检测

```typescript
class UpdateTracker {
  private lastSequence = 0;
  private missingSequences: Set<number> = new Set();
  
  handleUpdate(update: SyncUpdate): void {
    // 检测序列号跳跃
    if (update.sequence > this.lastSequence + 1) {
      // 发现丢失的更新
      for (let i = this.lastSequence + 1; i < update.sequence; i++) {
        this.missingSequences.add(i);
      }
      
      logger.warn('Detected missing updates', {
        expected: this.lastSequence + 1,
        received: update.sequence,
        missing: Array.from(this.missingSequences),
      });
      
      // 请求补发丢失的更新
      this.requestMissingUpdates();
    }
    
    // 移除已收到的序列号
    this.missingSequences.delete(update.sequence);
    this.lastSequence = Math.max(this.lastSequence, update.sequence);
  }
  
  async requestMissingUpdates(): Promise<void> {
    if (this.missingSequences.size > 10) {
      // 丢失太多，执行完整同步
      logger.warn('Too many missing updates, performing full sync');
      await this.performFullSync();
      this.missingSequences.clear();
    } else {
      // 请求补发特定更新
      for (const seq of this.missingSequences) {
        await this.requestUpdate(seq);
      }
    }
  }
}
```

### 3. 数据一致性校验

```typescript
class ConsistencyChecker {
  private checkInterval = 5 * 60 * 1000; // 5分钟
  
  startPeriodicCheck(): void {
    setInterval(() => {
      this.performCheck();
    }, this.checkInterval);
  }
  
  async performCheck(): Promise<void> {
    // 计算本地数据的校验和
    const localChecksum = this.calculateChecksum();
    
    // 从 Hub 获取校验和
    const hubChecksum = await this.hubClient.getChecksum();
    
    if (localChecksum !== hubChecksum) {
      logger.warn('Data inconsistency detected', {
        local: localChecksum,
        hub: hubChecksum,
      });
      
      // 执行完整重新同步
      await this.performFullSync();
    }
  }
  
  private calculateChecksum(): string {
    // 计算频道、ACL、封禁的校验和
    const data = {
      channels: Array.from(this.stateManager.channels.entries()),
      acls: Array.from(this.stateManager.acls.entries()),
      bans: this.stateManager.bans.getAll(),
    };
    
    return crypto.createHash('sha256')
      .update(JSON.stringify(data))
      .digest('hex');
  }
}
```

## 性能优化

### 1. 批量更新

```typescript
class UpdateBatcher {
  private batch: SyncUpdate[] = [];
  private batchSize = 100;
  private batchTimeout = 100; // 100ms
  private timer: NodeJS.Timeout | null = null;
  
  add(update: SyncUpdate): void {
    this.batch.push(update);
    
    if (this.batch.length >= this.batchSize) {
      this.flush();
    } else if (!this.timer) {
      this.timer = setTimeout(() => this.flush(), this.batchTimeout);
    }
  }
  
  private async flush(): Promise<void> {
    if (this.batch.length === 0) return;
    
    const updates = this.batch.splice(0);
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    
    // 批量处理更新
    await this.stateManager.handleBatchUpdates(updates);
  }
}
```

### 2. 差异化同步

```typescript
// Hub Server 实现
class DeltaSyncService {
  /**
   * 生成增量快照（仅包含变化的数据）
   */
  async generateDeltaSnapshot(
    edgeServerId: number,
    fromTimestamp: number
  ): Promise<DeltaSnapshot> {
    // 查询变化的频道
    const changedChannels = this.db.prepare(`
      SELECT * FROM channels 
      WHERE updated_at > ?
    `).all(new Date(fromTimestamp));
    
    // 查询变化的 ACL
    const changedACLs = this.db.prepare(`
      SELECT * FROM acls 
      WHERE (updated_at > ? OR deleted_at > ?)
        AND deleted_at IS NULL
    `).all(new Date(fromTimestamp), new Date(fromTimestamp));
    
    // 查询新增/删除的封禁
    const changedBans = this.db.prepare(`
      SELECT * FROM bans 
      WHERE (created_at > ? OR deleted_at > ?)
    `).all(new Date(fromTimestamp), new Date(fromTimestamp));
    
    return {
      channels: changedChannels,
      acls: changedACLs,
      bans: changedBans,
      deletedChannelIds: [], // 需要单独查询
      deletedACLIds: [],
      deletedBanIds: [],
      timestamp: Date.now(),
    };
  }
}
```

## 监控和调试

### 同步状态监控

```typescript
class SyncMonitor {
  private metrics = {
    lastSyncTime: 0,
    totalUpdates: 0,
    failedUpdates: 0,
    syncLatency: 0,
    missedUpdates: 0,
  };
  
  recordUpdate(update: SyncUpdate, latency: number): void {
    this.metrics.lastSyncTime = Date.now();
    this.metrics.totalUpdates++;
    this.metrics.syncLatency = latency;
  }
  
  recordFailure(): void {
    this.metrics.failedUpdates++;
  }
  
  getMetrics(): SyncMetrics {
    return {
      ...this.metrics,
      isHealthy: this.isHealthy(),
    };
  }
  
  private isHealthy(): boolean {
    const timeSinceLastSync = Date.now() - this.metrics.lastSyncTime;
    return timeSinceLastSync < 60000 && // 1分钟内有更新
           this.metrics.failedUpdates < 10; // 失败次数少于10次
  }
}
```

### 调试工具

```typescript
// 提供调试命令
class SyncDebugger {
  async dumpState(): Promise<void> {
    console.log('=== Edge Server State ===');
    console.log('Channels:', this.stateManager.channels.size);
    console.log('ACLs:', this.stateManager.acls.size);
    console.log('Bans:', this.stateManager.bans.size());
    console.log('Last Sync:', new Date(this.stateManager.lastSyncTimestamp));
  }
  
  async compareWithHub(): Promise<void> {
    const hubSnapshot = await this.hubClient.requestFullSnapshot({});
    const localState = this.stateManager.exportState();
    
    const diff = this.computeDiff(hubSnapshot, localState);
    console.log('Differences:', diff);
  }
}
```

## 实现清单

### Hub Server
- [x] SQLite 数据库模型（已完成）
- [ ] gRPC 同步服务实现
- [ ] 数据变更广播机制
- [ ] 快照生成服务
- [ ] 增量更新推送

### Edge Server
- [ ] 移除 SQLite 依赖
- [ ] 内存状态管理器
- [ ] gRPC 同步客户端
- [ ] 断线重连机制
- [ ] 数据一致性校验

### 通用
- [ ] Protobuf 定义
- [ ] 监控和指标
- [ ] 调试工具
- [ ] 集成测试

## 总结

这个架构确保了：

1. **单一数据源**：Hub Server 是唯一的持久化存储
2. **低延迟**：Edge Server 从内存读取，无数据库 I/O
3. **最终一致性**：通过增量同步和定期校验保证一致性
4. **容错性**：断线重连、丢失检测、完整重新同步
5. **可扩展性**：支持大量 Edge Server 并发连接
6. **可观测性**：丰富的监控和调试工具
