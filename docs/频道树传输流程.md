1. 服务端频道树递归发送逻辑
服务端通常会在用户登录认证通过后，把完整频道树发送给客户端，各频道使用 ChannelState protobuf 消息逐个递归发送。核心逻辑如下：

C++
// src/murmur/Messages.cpp
// Transmit channel tree
QQueue< Channel * > q;
QSet< Channel * > chans;
q << root;
MumbleProto::ChannelState mpcs;
while (!q.isEmpty()) {
    c = q.dequeue();
    chans.insert(c);

    mpcs.Clear();
    mpcs.set_channel_id(c->iId);
    if (c->cParent)
        mpcs.set_parent(c->cParent->iId);
    if (c->iId == 0)
        mpcs.set_name(u8(qsRegName.isEmpty() ? QLatin1String("Root") : qsRegName));
    else
        mpcs.set_name(u8(c->qsName));
    mpcs.set_position(c->iPosition);
    // 其他属性可选：description、links、temporary等
    // 发送频道消息
    sendMessage(uSource, mpcs);

    // 递归队列扩展
    for (Channel *chan : c->qlChannels)
        q << chan;
}
服务端递归遍历频道树，每一个 Channel 都会单独推送一条 ChannelState 消息给客户端。每个频道都包含自己的父频道信息（parent_id）、名称等。

2. ChannelState 消息结构（核心字段）
channel_id：频道唯一ID
parent：父频道ID
name：频道名称
position：展示顺序
description：频道描述（可选）
links：频道间的链接（可选）
参考 MumbleProto::ChannelState 定义，服务端可选带其他补充字段。

3. 客户端接收逻辑
客户端收到每一条 ChannelState 消息，会用于构建/更新本地频道树：

C++
// src/mumble/MainWindow.h (方法声明)
void channelStateChanged(Channel *channel, bool forceUpdateTree);
// src/mumble/MainWindow.cpp (响应tcp消息)
void MainWindow::msgChannelState(const MumbleProto::ChannelState &msg) {
    // 解析ChannelState，更新本地频道结构
    Channel *chan = Channel::getOrCreate(msg.channel_id());
    // 设置名称、父频道、描述等
    // 并递归更新UI、树结构
    emit channelStateChanged(chan, true);
}
客户端会根据收到的频道ID与parent字段递归整理树状结构，将所有频道构造成完整本地频道树，UI即可正确显示。

4. 完整频道树递归流程（时序图）
plaintext
服务端                     客户端
 |-- ChannelState(root) --->|
 |-- ChannelState(child1) ->|
 |-- ChannelState(child2) ->|
 |-- ChannelState(child2.1)->|
 ...（递归）
客户端根据每条 ChannelState:
  Channel[channel_id] = {
    name, parent_id, 描述, 位置...
  }
  按 parent_id 组织为树
5. 服务端构造树的补充（RPC接口）
MumbleServerIce.cpp 的 recurseTree 关键递归构造频道树
也可通过 ICE/RPC 直接获得频道树结构
C++
TreePtr recurseTree(const ::Channel *c) {
    TreePtr t = new Tree();
    channelToChannel(c, t->c);
    // 遍历用户
    for (const ::User *p : users) {...}
    // 遍历子频道
    for (const ::Channel *chn : channels) {
        t->children.push_back(recurseTree(chn));
    }
    return t;
}
6. 相关协议/消息定义
ChannelState: proto 结构化频道状态消息
UserState: 用户分配到频道消息
TextMessage: 可带树型发消息 add_tree_id(channelId)
总结
频道树的传递过程是服务端认证后，服务器通过递归遍历频道，每个频道用单独 ChannelState 消息发送到客户端，客户端根据消息 parent 字段和频道ID重建树状结构。主流程与 UI自动绑定，实现频道结构的完整还原。